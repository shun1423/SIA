# Self-Initiating Agent Architecture (SIA)

---

# 1. 배경 및 목적

현재 AI 에이전트 시장은 LangChain, AutoGen, CrewAI 등의 프레임워크가 주도하고 있습니다. 그러나 이들 프레임워크를 실제로 사용해보면 공통적인 특징이 있습니다.

**모두 사용자가 먼저 시작해야 합니다.**

"이거 해줘"라고 명령해야 움직입니다. 문제가 무엇인지 정의하는 것도, 어떤 도구를 쓸지 선택하는 것도, 실행을 지시하는 것도 전부 사람의 몫입니다. AI는 지시에 따라 실행할 뿐입니다.

SIA는 이 구조를 근본적으로 바꾸고자 합니다.

| 현재 방식 | SIA 방식 |
| --- | --- |
| 사람이 문제를 정의합니다 | AI가 문제를 발견합니다 |
| 사람이 해결책을 설계합니다 | AI가 해결책을 제안합니다 |
| 사람이 도구를 선택합니다 | AI가 필요한 도구를 조합합니다 |
| 한 번 실행하고 끝납니다 | 결과를 보고 다음에 더 잘합니다 |

한마디로, **도구를 파트너로 전환하는 것**입니다.

---

# 2. 문제 정의

## 2.1 현재 AI 에이전트의 작동 방식

```
사용자: "이런 앱 만들어줘"
         ↓
사용자가 LLM 선택 (GPT, Claude 등)
         ↓
사용자가 도구 연결 (검색, DB, API 등)
         ↓
프레임워크가 실행
         ↓
결과 반환 → 종료

```

모든 시작점이 사람입니다. AI는 기다리다가 반응할 뿐, 스스로 시작하지 못합니다.

## 2.2 구체적인 한계

**1) 문제를 인식하지 못합니다**

사용자가 "문제가 무엇인지" 직접 말해줘야 합니다. 예를 들어 메일함에 중요한 메일이 묻혀 있어도, 사용자가 "중요한 메일 찾아줘"라고 요청하기 전까지는 아무것도 하지 않습니다.

**2) 맥락이 단절됩니다**

어제 나눈 대화, 지난주에 했던 작업이 다음 대화에 이어지지 않습니다. 매번 처음부터 설명해야 합니다.

**3) 수동적으로 대기합니다**

프롬프트가 없으면 아무것도 하지 않습니다. 사용자가 문제를 인식하고, 표현하고, 요청하기 전까지 그냥 대기 상태입니다.

**4) 학습하지 않습니다**

같은 유형의 실수를 반복합니다. 이전에 무엇을 잘했고 무엇을 못했는지 기억하지 못합니다.

## 2.3 도구와 파트너의 차이

| 도구 (현재) | 파트너 (SIA) |
| --- | --- |
| 시키면 합니다 | 필요한 것을 먼저 파악합니다 |
| 맥락을 모릅니다 | 상황을 이해합니다 |
| 반복해도 똑같습니다 | 경험에서 배웁니다 |
| 수동적입니다 | 능동적입니다 |

---

# 3. 관련 연구 검토

SIA의 핵심 개념과 관련된 기존 연구를 조사한 결과, 개별 요소에 대한 연구는 존재하지만 SIA가 제시하는 통합적 프레임워크는 아직 없습니다.

## 3.1 Proactive Agent (ICLR 2025, 칭화대)

"사용자가 요청하기 전에 먼저 도움을 제안하는 에이전트"에 대한 연구입니다. 문제의식은 SIA와 유사합니다.

**그러나 다음과 같은 한계가 있습니다:**

- 관찰 범위가 브라우저, VSCode, 윈도우 앱 등 데스크톱으로 한정됩니다
- 사전에 정의된 3가지 시나리오(코딩, 글쓰기, 일상)에서만 작동합니다
- "언제 제안할 것인가"에만 집중하며, "무엇이 문제인가"는 탐색하지 못합니다
- World Model 개념이 없습니다

**SIA와의 차별점:**

- SIA는 MCP(Model Context Protocol)를 통해 이메일, 캘린더, Slack, DB, API 등 전체 시스템을 관찰 대상으로 합니다
- 새로운 문제를 스스로 발견하는 Gap Detection 계층이 있습니다
- 사용자 정보가 World Model에 지속적으로 축적됩니다

## 3.2 World Model 연구 (RAP, LAW 등)

LLM에 "세상이 어떻게 작동하는지" 가르치는 연구들입니다.

**그러나 용도가 다릅니다:**

- 이 연구들은 "추론 성능 향상"이 목적입니다
- 하나의 태스크 안에서 상태를 예측하는 데 사용됩니다
- 태스크가 끝나면 사라집니다

**SIA의 World Model은:**

- 사용자의 목표, 습관, 선호를 장기적으로 저장합니다
- 태스크가 끝나도 유지됩니다
- Learning Layer를 통해 계속 업데이트됩니다

## 3.3 MCP (Model Context Protocol)

Anthropic이 2024년에 발표한 도구 연결 표준입니다. OpenAI, Google 등 주요 기업들도 채택했으며, 이미 수천 개의 서버가 개발되어 있습니다.

**현재 MCP 활용 방식:**

- 어떤 도구를 연결할지 사람이 결정합니다
- 코드에 하드코딩합니다

**SIA의 방식:**

- AI가 솔루션을 분석하여 필요한 도구를 자율적으로 선택합니다
- 런타임에 동적으로 조합합니다

## 3.4 항상성(Homeostasis) 기반 AI 연구

생물학의 항상성 원리를 AI에 적용하는 연구가 있습니다.

**그러나:**

- 전부 저수준 제어에만 적용됩니다 (로봇 온도 조절 등)
- 고수준 사용자 목표 관리에 적용한 사례가 없습니다

## 3.5 연구 공백 정리

| SIA 요소 | 기존 연구 현황 |
| --- | --- |
| 10계층 통합 아키텍처 | **없음** |
| Gap Detection 전용 계층 (현재 vs 이상 비교) | **없음** |
| AI의 자율적 도구 선택 및 조합 | **없음** |
| 사용자 목표 관리에 항상성 원리 적용 | **없음** |
| 문제 발견 → 솔루션 탐색 → 도구 구성 파이프라인 | **없음** |

개별 조각은 여기저기 존재하지만, 이를 하나로 엮은 프레임워크는 아직 없습니다.

---

# 4. SIA 아키텍처 개요

## 4.1 핵심 원리

SIA의 설계는 생물의 항상성(Homeostasis)에서 착안했습니다.

체온이 떨어지면 몸이 떨립니다. 올라가면 땀이 납니다. 아무도 시키지 않아도 그렇게 합니다. "정상 체온"이라는 기준이 있고, 거기서 벗어나면 자동으로 반응하기 때문입니다.

SIA도 같은 원리로 작동합니다.

> "이상적 상태"와 "현재 상태"를 비교하여, 차이가 발생하면 스스로 행동합니다.
> 

## 4.2 전체 구조

SIA는 10개의 계층으로 구성됩니다. 각 계층은 명확한 역할을 가지며, 순차적으로 연결되어 순환 구조를 형성합니다.

```
┌──────────────────────────────────────┐
│           WORLD MODEL                │
│   사용자 목표 / 선호 / 패턴 저장소     │
└───────────────┬──────────────────────┘
                ↓
┌──────────────────────────────────────┐
│           SENSOR LAYER               │
│      MCP로 메일, 캘린더 등 관찰       │
└───────────────┬──────────────────────┘
                ↓
┌──────────────────────────────────────┐
│        EXPECTATION LAYER             │
│    현재 상황에서 이상적인 상태 생성    │
└───────────────┬──────────────────────┘
                ↓
┌──────────────────────────────────────┐
│         COMPARISON LAYER             │
│        현재 상태 vs 이상 상태         │
└───────────────┬──────────────────────┘
                ↓
┌──────────────────────────────────────┐
│       INTERPRETATION LAYER           │
│       Gap을 "문제"로 정의            │
└───────────────┬──────────────────────┘
                ↓
┌──────────────────────────────────────┐
│        EXPLORATION LAYER             │
│         해결책 후보 탐색              │
└───────────────┬──────────────────────┘
                ↓
┌──────────────────────────────────────┐
│          PROPOSAL LAYER              │
│     사용자에게 제안 + 승인 요청       │
└───────────────┬──────────────────────┘
                ↓
┌──────────────────────────────────────┐
│        COMPOSITION LAYER             │
│      LLM + 도구 동적 선택/조합        │
└───────────────┬──────────────────────┘
                ↓
┌──────────────────────────────────────┐
│         EXECUTION LAYER              │
│              실행                    │
└───────────────┬──────────────────────┘
                ↓
┌──────────────────────────────────────┐
│          LEARNING LAYER              │
│    결과 관찰 → World Model 업데이트   │
└───────────────┴──────────────────────┘
                ↓
          (다시 World Model로 피드백)

```

---

# 5. 각 계층 상세 설명

## 5.1 World Model (세계 모델)

### 정의

사용자의 목표, 선호, 행동 패턴, 이상적 상태를 저장하고 지속적으로 업데이트하는 중앙 지식 저장소입니다.

### 역할

- 사용자가 "무엇을 원하는지" 모델링합니다
- "무엇이 좋은 상태인지" 기준을 제공합니다
- 시간이 지남에 따라 점점 정교해집니다

### 데이터 구조 예시

```
User: 김철수
├── Goals (목표)
│   ├── "아침에 중요한 업무 메일 먼저 처리"
│   └── "주간보고 마감 절대 놓치지 않기"
├── Preferences (선호)
│   ├── 알림: 최소화
│   └── 자동화: 적극 수용
├── Patterns (패턴)
│   ├── 월요일 오전: 메일 집중 처리
│   └── 금요일 오후: 보고서 작성
└── Ideal States (이상적 상태)
    ├── 중요 메일: 30분 내 확인
    └── 마감: 24시간 전 리마인더

```

### 이상적 상태는 어떻게 생성되는가

World Model의 핵심인 "이상적 상태(Ideal State)"는 다음 세 가지 방법의 조합으로 생성됩니다.

**1) 명시적 설정 (사용자가 직접 입력)**

온보딩 과정이나 설정 화면에서 사용자가 직접 목표를 입력합니다.

```
예시:
- "중요한 메일은 30분 안에 확인하고 싶어요"
- "마감 하루 전에 알림 받고 싶어요"
- "회의 시작 10분 전에 준비 시간이 필요해요"

```

**2) 암묵적 학습 (행동 패턴에서 추론)**

사용자의 행동을 관찰하여 AI가 선호를 추론합니다.

```
관찰: 사용자가 항상 마케팅팀 메일을 가장 먼저 연다
추론: "마케팅팀 메일 = 높은 우선순위"

관찰: 사용자가 금요일 오후에 주간보고를 작성한다
추론: "금요일 오후 = 보고서 작성 시간"

```

**3) 기본값 + 점진적 조정**

도메인별 합리적인 기본값에서 시작하여, 사용자 반응을 보고 조정합니다.

```
기본값: "업무 메일은 1시간 내 확인이 이상적"
관찰: 사용자가 제안을 계속 무시함
조정: "이 사용자는 4시간 정도가 적절한 듯" → 임계값 조정

```

### 콜드스타트 전략

처음 사용 시에는 다음 순서로 World Model을 구축합니다:

| 단계 | 방법 | 예시 |
| --- | --- | --- |
| 1단계 | 간단한 온보딩 질문 (3~5개) | "가장 중요한 업무 목표가 뭔가요?" |
| 2단계 | 도메인별 기본값 적용 | 이메일: 1시간 내 확인 권장 |
| 3단계 | 1~2주간 행동 관찰 | 어떤 메일을 먼저 여는지 패턴 분석 |
| 4단계 | 추론 결과 확인 요청 | "마케팅팀 메일을 중요하게 보시는 것 같은데, 맞나요?" |
| 5단계 | 지속적 피드백 반영 | Proposal 승인/거절 기록으로 학습 |

### 오류 수정 메커니즘

AI가 이상적 상태를 잘못 추론했을 경우, 다음 경로로 수정됩니다:

1. **Proposal 거절**: 사용자가 제안을 거절하면 해당 추론의 신뢰도를 낮춥니다
2. **명시적 피드백**: "아니, 그건 중요하지 않아"라고 직접 말하면 즉시 수정합니다
3. **행동 불일치 감지**: 추론과 다른 행동이 반복되면 자동으로 재조정합니다

## 5.2 Sensor Layer (센서 계층)

### 정의

MCP를 통해 외부 데이터 소스와 연결하여 현재 상태를 지속적으로 수집하는 계층입니다.

### 역할

- 다양한 데이터 소스 연결 (이메일, 캘린더, 메신저, 파일 등)
- 실시간 또는 주기적 데이터 수집
- 원시 데이터를 구조화된 형태로 변환

### 연결 가능한 소스 예시

- **커뮤니케이션**: Gmail, Slack, Microsoft Teams
- **생산성**: Google Calendar, Notion, Trello, Jira
- **개발**: GitHub, GitLab
- **데이터**: 사내 DB, API, 파일 시스템

## 5.3 Expectation Layer (기대 계층)

### 정의

World Model을 기반으로 "현재 상황에서 이상적인 상태는 무엇인가"를 동적으로 생성하는 계층입니다.

### 역할

- 현재 맥락에 맞는 기대 상태 생성
- 시간, 상황, 패턴을 고려한 동적 기대 생성

### 작동 예시

```
입력:
  - 현재 시각: 월요일 오전 9시
  - 현재 상태: 메일함에 52개의 새 메일
  - World Model: "아침에 중요한 업무 메일 먼저 처리"

출력:
  - Expectation: "중요 메일이 상단에 보여야 함"

```

## 5.4 Comparison Layer (비교 계층)

### 정의

Sensor Layer가 수집한 현재 상태와 Expectation Layer가 생성한 이상적 상태를 비교하는 계층입니다.

### 역할

- 두 상태 간의 차이(Gap) 측정
- 차이의 크기와 중요도 평가

### 작동 예시

```
현재 상태: 메일이 시간순 정렬, 중요 메일이 40번째에 위치
이상 상태: 중요 메일이 상단에 위치

결과: Gap 감지 - "중요 메일 가시성 문제" (중요도: 높음)

```

## 5.5 Interpretation Layer (해석 계층)

### 정의

발견된 Gap을 인간이 이해할 수 있는 "문제"로 명명하고, 그 의미와 영향을 해석하는 계층입니다.

### 역할

- Gap을 구체적인 문제로 변환
- 문제의 원인 분석
- 해결하지 않을 경우의 영향 예측

### 작동 예시

```
Gap: "중요 메일 가시성 문제"

해석 결과:
  - Problem: "중요 업무 메일을 놓칠 수 있음"
  - Cause: "메일함이 시간순 정렬로 고정됨"
  - Impact: "응답 지연 → 업무 차질"

```

## 5.6 Exploration Layer (탐색 계층)

### 정의

정의된 문제에 대해 가능한 솔루션들을 탐색하고 평가하는 계층입니다.

### 역할

- 다양한 해결 방안 생성
- 각 방안의 장단점 분석
- 구현 가능성 평가

### 작동 예시

```
Problem: "중요 업무 메일을 놓칠 수 있음"

탐색된 솔루션:
┌─────────────────────────────────────────┐
│ 1. 자동 분류 시스템 구축                 │
│    장점: 근본적 해결                    │
│    단점: 초기 설정 필요                 │
│    구현 복잡도: 중                      │
├─────────────────────────────────────────┤
│ 2. 중요 메일 실시간 알림                 │
│    장점: 즉시 적용 가능                 │
│    단점: 알림 피로도 증가 가능           │
│    구현 복잡도: 하                      │
├─────────────────────────────────────────┤
│ 3. 아침 요약 리포트 자동 생성            │
│    장점: 비침습적                       │
│    단점: 실시간성 부족                  │
│    구현 복잡도: 중                      │
└─────────────────────────────────────────┘

```

## 5.7 Proposal Layer (제안 계층)

### 정의

탐색된 솔루션 중 최적안을 선택하여 사용자에게 제안하고 승인을 받는 계층입니다.

### Human-in-the-Loop

SIA는 완전 자율 시스템이 아닙니다. Proposal Layer에서 반드시 사용자 승인을 거치도록 설계하여, 사용자가 최종 결정권을 유지합니다.

### 제안 인터페이스 예시

```
[SIA 제안]

발견한 문제:
지난 2주간 중요 메일 평균 응답 시간이 4시간이었습니다.

권장 솔루션: 자동 분류 시스템

선택 이유:
• 발신자와 키워드 패턴 분석 결과, 자동 분류가 가능합니다
• 한 번 설정하면 지속적으로 작동합니다
• 알림 피로도를 유발하지 않습니다

[승인] [다른 방안 요청] [거절]

```

## 5.8 Composition Layer (구성 계층)

### 정의

승인된 솔루션을 구현하기 위해 필요한 LLM과 MCP 도구를 동적으로 선택하고 연결하는 계층입니다.

### 핵심 차별점

기존 프레임워크는 사람이 도구를 선택합니다. SIA는 AI가 솔루션의 요구사항을 분석하여 적합한 도구를 자율적으로 구성합니다.

### 구성 예시

```
솔루션: "자동 분류 시스템"

Composition 결과:
├── LLM: Claude 3.5 Sonnet (분류 판단용)
├── MCP Servers
│   ├── Gmail MCP (메일 접근)
│   ├── Calendar MCP (맥락 참조)
│   └── Slack MCP (팀 커뮤니케이션 맥락)
├── Logic
│   ├── 발신자 기반 우선순위 규칙
│   ├── 키워드 기반 분류 로직
│   └── 긴급도 점수 산출 알고리즘
└── Output
    └── 라벨 적용 + 정렬 + 알림 (선택적)

```

## 5.9 Execution Layer (실행 계층)

### 정의

Composition Layer에서 구성된 시스템을 실제로 실행하는 계층입니다.

### 역할

- 솔루션 배포 및 실행
- 실행 상태 모니터링
- 오류 처리 및 복구

## 5.10 Learning Layer (학습 계층)

### 정의

실행 결과를 관찰하고, 이를 바탕으로 World Model을 업데이트하는 계층입니다.

### 역할

- 실행 결과 측정 (성공/실패, 사용자 만족도)
- 패턴 학습
- World Model 업데이트
- 다음 사이클에 반영

### 작동 예시

```
결과 관찰:
  - 분류 정확도: 87%
  - 중요 메일 응답 시간: 4시간 → 45분
  - 사용자 피드백: "마케팅 메일도 중요하게 봐야 함"

World Model 업데이트:
  - Preference 추가: "마케팅팀 메일 = 높은 우선순위"
  - Pattern 추가: "마케팅팀 발신 메일 → 우선순위 상향 적용"

```

이 과정이 계속 반복되면서 시스템이 점점 똑똑해집니다.

---

# 6. 기존 프레임워크와의 비교

| 항목 | LangChain / AutoGen | SIA |
| --- | --- | --- |
| **패러다임** | 반응형 (Reactive) | 능동형 (Proactive) |
| **시작점** | 사용자의 명령 | AI의 관찰 |
| **문제 정의** | 사람이 합니다 | AI가 발견합니다 |
| **솔루션 설계** | 사람이 합니다 | AI가 제안 + 사람이 승인 |
| **도구 선택** | 코드에 하드코딩 | 런타임에 동적 선택 |
| **실행 방식** | 일회성 | 순환/지속 |
| **학습** | 없음 | World Model 업데이트 |
| **맥락 유지** | 프롬프트에 의존 | 축적된 World Model |

---

# 7. 설계 근거

## 7.1 항상성 (Homeostasis)

생명체는 내부 환경을 일정하게 유지하려 합니다. 체온이 떨어지면 떨고, 올라가면 땀을 흘립니다. SIA도 마찬가지로, "이상적 상태"를 정의하고 거기서 벗어나면 행동합니다.

- **Set Point**: World Model에 정의된 이상적 상태
- **Sensor**: Sensor Layer를 통한 현재 상태 감지
- **Comparator**: Comparison Layer에서 Gap 감지
- **Effector**: Execution Layer를 통한 조정 행동

## 7.2 지향성 (Intentionality)

현상학에서 의식은 항상 "무엇에 대한" 의식입니다. SIA는 World Model을 통해 "목표"와 "이상"을 가짐으로써, 단순한 반응을 넘어 의도를 가진 행동을 수행합니다.

## 7.3 순환적 인과 (Circular Causality)

행동 → 결과 → 학습 → 행동의 순환 구조를 통해 시스템이 자신의 행동 결과로부터 스스로를 개선합니다.

---

# 8. 기술 구현 방향

## 8.1 기술 스택 (권장)

| 계층 | 기술 |
| --- | --- |
| World Model | Vector DB (Pinecone, Weaviate) + Knowledge Graph |
| Sensor Layer | MCP Server 연동 |
| Expectation / Comparison / Interpretation | LLM Reasoning (Claude, GPT-4) |
| Exploration | LLM + Search + Evaluation |
| Composition | Dynamic MCP Orchestration |
| Learning | Feedback Loop + Embedding Update |

## 8.2 단계별 개발 계획

**Phase 1: 단일 도메인 PoC (8주)**

- 범위: 이메일 도메인
- 목표: 10계층 파이프라인 검증
- 산출물: 작동하는 프로토타입

**Phase 2: 다중 도메인 확장 (12주)**

- 범위: 이메일 + 캘린더 + Slack
- 목표: 도메인 간 연동 검증
- 산출물: 통합 데모 시스템

**Phase 3: 범용 프레임워크 (16주)**

- 범위: 임의의 MCP 서버 지원
- 목표: 오픈소스 프레임워크 배포
- 산출물: 공개 가능한 SDK

## 8.3 주요 기술적 도전 과제

| 도전 과제 | 접근 방향 |
| --- | --- |
| World Model 정확성 | 명시적 피드백 + 암묵적 행동 패턴 분석 병행 |
| Gap 판단의 신뢰성 | Confidence Score 기반 임계값 설정 |
| 제안 타이밍 최적화 | 사용자 상태 감지 + 적응형 빈도 조절 |
| 프라이버시 보호 | 로컬 우선 처리 + 민감 데이터 암호화 |

---

# 9. 결론

LangChain이 "LLM에 도구를 붙인다"는 패러다임을 열었다면, SIA는 "AI가 스스로 시작한다"는 다음 패러다임을 제시합니다.

이것은 AI를 도구에서 파트너로 전환하는 것입니다. 사용자가 무엇을 원하는지 말하기 전에, AI가 먼저 필요를 발견하고 제안하는 구조입니다.

### 핵심 기여

1. **Gap Detection의 명시적 계층화**: 현재 상태와 이상적 상태를 비교하는 Comparison Layer를 독립 계층으로 분리했습니다
2. **항상성 원리의 고수준 적용**: 저수준 제어가 아닌 사용자 목표 관리에 항상성 원리를 적용했습니다
3. **동적 도구 구성**: AI가 솔루션 요구사항을 분석하여 MCP 도구를 자율적으로 선택합니다
4. **순환 학습 구조**: 실행 결과가 World Model에 반영되어 시스템이 점진적으로 개선됩니다

이 조합은 현재 AI 인프라 위에서 아직 구현되지 않은 영역이며, 저희가 만들어야 할 것입니다.

---

# 10. 다음 단계

| 순서 | 내용 | 산출물 |
| --- | --- | --- |
| 1 | World Model 스키마 설계 | 데이터 구조 명세서 |
| 2 | Sensor Layer 구현 (Gmail MCP) | 프로토타입 코드 |
| 3 | Comparison Layer 로직 개발 | Gap Detection 알고리즘 |
| 4 | Proposal Layer UI 설계 | 인터페이스 목업 |
| 5 | 이메일 도메인 PoC 개발 | 작동하는 데모 시스템 |
| 6 | 사용자 테스트 및 피드백 반영 | 개선된 v2 시스템 |

---

# 참고 문헌

1. Proactive Agent: Shifting LLM Agents from Reactive Responses to Active Assistance (ICLR 2025)
2. Reasoning with Language Model is Planning with World Model - RAP (EMNLP 2023)
3. Language Models, Agent Models, and World Models: The LAW for Machine Reasoning and Planning (2023)
4. Agent Planning with World Knowledge Model (NeurIPS 2024)
5. Homeostatically Regulated Reinforcement Learning (2025)
6. Model Context Protocol Specification (Anthropic, 2024)
7. A Survey on Large Language Model based Autonomous Agents (2023)
8. Agentic AI: Autonomous Intelligence for Complex Goals - A Comprehensive Survey (IEEE Access, 2025)

---

**Self-Initiating Agent Architecture (SIA) — White Paper v2.0**

*작성일: 2025년 12월*