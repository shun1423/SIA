# Self-Initiating Agent Architecture (SIA)

## White Paper v3.2

_작성일: 2025년 1월 5일_
_원작성자: 강성훈_

---

## Executive Summary

현재의 에이전트 프레임워크(LangChain, AutoGen, CrewAI 등)는 '사용자가 문제를 정의하고 실행을 지시'하는 방식에 최적화되어 있습니다. 하지만 현실에서는 사용자가 비효율을 느끼면서도 무엇이 문제인지 정확히 모르는 경우가 많습니다.

**SIA(Self-Initiating Agent Architecture)**는 사용자가 '추상적 목표'만 제공하면(예: "업무 효율 높이고 싶어"), 시스템이 다양한 데이터 소스를 관찰해 문제 후보를 발견하고, 해결을 위한 에이전트를 자동으로 구성·제안하며, 사용자 승인 후 실행-학습 루프를 통해 지속적으로 개선되는 **메타 에이전트**입니다.

### 핵심 차별점

1. **문제 정의의 자동화(Problem Discovery)**: 사용자가 문제를 모르는 상태에서 시작 가능
2. **발견된 문제에 맞춘 에이전트의 동적 구성(Dynamic Composition)**: 문제마다 맞춤형 에이전트 자동 생성
3. **개인화 학습 루프(Feedback-to-Model)**: 사용자 피드백이 즉시 반영되는 개인화

### 안전성 원칙

SIA는 완전 자율 시스템을 지향하지 않습니다. 모든 '쓰기(Write) 작업'은 기본적으로 차단되고, **최소 권한 원칙**과 **Human-in-the-Loop(승인 기반 실행)**를 통해 프라이버시·안전성을 확보합니다.

### 초기 검증 범위

초기 검증은 Gmail + Calendar 중심의 제한된 도메인에서 시작하며, 다음을 KPI로 측정합니다:
- 제안 승인율
- 문제 제안 정밀도(precision)
- 에이전트 적용 전후 핵심 지표 개선(응답시간, 누락 건수 등)

---

## 용어집

| 용어 | 정의 |
|------|------|
| **추상적 목표(Abstract Goal)** | 사용자가 원하는 방향성. 측정 가능한 규칙이 아니라 '중요한 것을 놓치지 않기', '업무 효율 향상' 등 상위 목표 |
| **관찰(Observation)** | 외부 시스템으로부터 읽어온 원시 이벤트/메타데이터. 예: '새 메일 도착', '미팅 시작' |
| **특징/패턴(Feature/Pattern)** | 관찰로부터 추출된 요약 정보. 예: 평균 응답시간, 반복 지출 패턴 (원본 콘텐츠와 구분) |
| **기대 상태(Expectation)** | 추상적 목표를 현재 맥락에 맞게 구체화한 '이상적 상태' 가설 |
| **Gap** | 현재 상태와 기대 상태의 차이 |
| **문제 후보(Problem Candidate)** | Gap이 일정 기준을 넘어서 '문제일 수 있음'으로 분류된 상태. 아직 확정 아님 |
| **확정 문제(Confirmed Problem)** | 사용자 확인(승인/수정)을 거쳐 문제로 확정된 상태 |
| **에이전트(Agent)** | 트리거 + 입력 + 도구(MCP) + 처리 로직 + 실행 액션으로 구성된 자동화 워크플로우 산출물 |
| **MCP(Model Context Protocol)** | LLM이 외부 시스템과 안전하게 연결되도록 돕는 도구/컨텍스트 연결 표준 |

---

## 비목표(Non-goals)

초기 버전에서 SIA는 다음을 **지향하지 않습니다**:

- **고위험 의사결정 대체**: 인사/채용/법률·의료 판단 등
- **민감 본문 콘텐츠의 상시 수집**: 사용자 명시적 동의 없이 메일/메신저 본문 수집
- **완전 자동 실행 중심의 운영**: 기본은 제안→승인 기반
- **모든 도메인을 즉시 커버하는 범용 에이전트 OS**: 초기에는 제한 도메인에서 깊게 검증

---

## 1. 배경 및 목적

현재 AI 에이전트 생태계는 다양한 프레임워크를 중심으로 발전하고 있습니다. 그러나 실사용 관점에서 이들 대부분은 공통적으로 **'사용자가 먼저 문제를 정의하고 실행을 지시해야'** 동작합니다.

현실에서는 사용자가 비효율을 느끼면서도 문제를 정확히 언어화하지 못하는 경우가 많습니다:
- "뭔가 바쁜데 왜 바쁜지 모르겠어"
- "시간이 부족한데 어디서 새는지 모르겠어"
- "뭔가 비효율적인 것 같은데 뭐가 문제인지 모르겠어"

SIA는 이 지점을 출발점으로 삼습니다. 사용자는 구체적 문제 대신 **'추상적 목표'**를 제공하고, SIA는 관찰을 통해 문제 후보를 발견한 뒤, 해결을 위한 에이전트를 자동으로 구성하여 제안합니다.

### 1.1 현재 방식 vs SIA 방식

| 현재 방식 | SIA 방식 |
|-----------|----------|
| 사람이 구체적인 문제를 정의 | 사람은 **추상적 목표**만 제공 |
| 사람이 해결책/워크플로우를 설계 | AI가 **문제를 발견**하고 해결책 후보(에이전트)를 제안 |
| 사람이 도구/에이전트를 선택 | AI가 필요한 도구와 에이전트를 **런타임에 자동 구성** |
| 일회성 실행 후 종료 | 관찰 → 발견 → 제안 → 실행 → 학습의 **지속 루프** |

---

## 2. 핵심 컨셉

### 2.1 SIA의 정의

SIA는 **'에이전트를 만들어주는 메타 에이전트'**입니다.

특정 과제를 수행하는 단일 에이전트가 아니라, 사용자 목표·맥락·관찰 데이터를 기반으로 **문제를 찾아내고**, 문제 해결을 위한 **에이전트를 생성·운영·개선**하는 상위 시스템입니다.

```
┌─────────────────────────────────────────────────────────┐
│                         SIA                             │
│                   (메타 에이전트)                        │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │ 문제 발견   │→│ 솔루션 설계  │→│ 에이전트 생성 │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
│         ↑                                    ↓          │
│         └────────────── 학습 ←───────────────┘          │
└─────────────────────────────────────────────────────────┘
                            ↓
              ┌─────────────────────────────┐
              │      생성된 에이전트들       │
              ├─────────────────────────────┤
              │ • 메일 분류 에이전트         │
              │ • PR 리뷰 리마인더 에이전트  │
              │ • 수면 패턴 트래커 에이전트  │
              │ • 지출 알림 에이전트         │
              │ • ...                       │
              └─────────────────────────────┘
```

### 2.2 동작 루프(High-level Loop)

```
사용자(추상 목표)
    ↓
관찰(센서/MCP)
    ↓
기대 상태 생성(Expectation)
    ↓
현재 상태 비교(Gap)
    ↓
문제 후보 생성 → 사용자 확인 → 문제 확정
    ↓
에이전트 탐색/구성(Composition)
    ↓
승인 후 실행(Execution)
    ↓
효과 측정/피드백 학습(Learning)
    ↺ 반복
```

### 2.3 문제 후보와 확정 문제의 분리

SIA의 핵심은 **'Gap을 곧바로 문제로 단정하지 않는 것'**입니다.

시스템은 Gap을 탐지하면 우선 **'문제 후보(Problem Candidate)'**로 등록하고, 사용자 확인(승인/거절/보류/수정)을 거쳐 **'확정 문제(Confirmed Problem)'**로 승격합니다.

**문제 상태 전이(State Machine)**

```
[Candidate] → (제안) → [Proposed] → (승인) → [Confirmed] → (해결/종료) → [Archived]
                     ├────────(거절)────────→ [Rejected]
                     └────────(보류)────────→ [Snoozed] → (재평가) → [Candidate]
```

---

## 3. 문제 정의

### 3.1 현재 에이전트의 한계

1. **사용자가 문제를 먼저 인식하고 표현해야 한다**
2. **문제를 알더라도 도구 선택·설계·운영이 사용자(혹은 개발자)의 책임이다**
3. **대화 수준의 기억만으로는 사용자의 장기 패턴/업무 흐름을 종합적으로 파악하기 어렵다**

### 3.2 SIA가 다루려는 영역

| 현재 방식 | SIA가 시도하는 방식 |
|-----------|---------------------|
| 사용자가 구체적 문제를 정의 | 사용자는 추상적 목표만 제공 |
| 사용자가 에이전트를 설계/선택 | SIA가 문제에 맞는 에이전트를 자동 구성 |
| 대화 단위의 맥락 유지 | 장기 관찰 기반의 World Model |
| 일회성 실행 | 지속적 관찰 → 문제 발견 → 해결 → 학습 |

---

## 4. 관련 연구 및 생태계

### 4.1 Proactive Agent (ICLR 2025)

Proactive Agent 연구는 사용자가 요청하기 전에 적절한 타이밍에 도움을 제안하는 에이전트를 다룹니다. SIA와 문제의식을 공유하지만, SIA는 **'언제 개입할 것인가'** 뿐 아니라 **'무엇이 문제인가'**를 먼저 탐색하고, 문제에 맞는 에이전트를 동적으로 생성하는 데 초점을 둡니다.

| Proactive Agent | SIA |
|-----------------|-----|
| "언제 제안할 것인가"에 집중 | "무엇이 문제인가"를 먼저 탐색 |
| 사전 정의된 도움을 제공 | 문제에 맞는 에이전트를 동적으로 생성 |
| 데스크톱 환경 관찰 | MCP 기반 다양한 데이터 소스 연결 |

### 4.2 MCP(Model Context Protocol)

MCP는 LLM이 이메일, 캘린더, 메신저, 데이터베이스 등 외부 시스템과 상호작용하도록 돕는 연결 표준입니다. SIA는 MCP를 다음 두 가지 용도로 활용합니다:

1. **관찰용 센서 연결**: 사용자의 일상 데이터 수집
2. **해결용 에이전트 구성**: 발견된 문제에 따라 필요한 MCP를 런타임에 선택하여 에이전트 구성

---

## 5. SIA 아키텍처

### 5.1 설계 원칙(Design Principles)

| 원칙 | 설명 |
|------|------|
| **Goal-first** | 사용자는 추상적 목표를 제공하고, 시스템이 문제를 정의한다 |
| **Human-in-the-loop** | 모든 자동화는 제안→승인 기반으로 시작한다 (특히 쓰기 작업) |
| **Least privilege** | 초기에는 메타데이터 중심의 읽기 전용으로 시작하고, 필요 시 최소 범위로 권한을 확장한다 |
| **Tiered reasoning** | 규칙/통계 기반 탐지(cheap) → LLM 해석/설명(expensive) → 정책/승인 기반 실행(guarded) |
| **Auditability** | 왜 이 제안을 했는지(근거), 무엇을 실행했는지(행동), 어떤 결과였는지(효과)를 추적 가능하게 설계한다 |

### 5.2 레이어드 구조

SIA는 인지/결정 파이프라인을 **10개 계층**으로 구성하되, 실제 제품 운영을 위해 보안·정책·관측(Observability) 같은 **'횡단 관심사'**를 별도 레이어로 둡니다.

**핵심 10계층(인지/결정 파이프라인)**

```
WORLD MODEL → SENSOR → EXPECTATION → COMPARISON → INTERPRETATION
     → EXPLORATION → PROPOSAL → COMPOSITION → EXECUTION → LEARNING
```

**횡단 레이어(Cross-cutting Layers)**

| 레이어 | 역할 | 예시 |
|--------|------|------|
| **Policy & Consent** | 권한/승인/행동 정책을 중앙에서 강제 | 쓰기 작업 기본 차단, allowlist 기반 승인 |
| **Security & Safety** | 프롬프트 인젝션, 데이터 유출, 멀티테넌트 격리 대응 | 외부 콘텐츠를 '명령'으로 해석하지 않기, 민감 데이터 필터 |
| **Observability & Auditing** | 실행 로그·근거·효과를 기록/감사 가능하게 | 제안 근거, 실행 결과, 실패율/지연 모니터링 |

### 5.3 목적함수: Problem Score(문제 점수)

SIA는 'Gap=문제'로 단정하지 않고, 목표 대비 기대 손실(utility loss)을 근사하는 **Problem Score**를 통해 문제 후보를 선별합니다.

**Problem Score 구성 요소**

| 요소 | 설명 |
|------|------|
| **지속성(Persistence)** | 일회성 이벤트가 아닌 반복/추세인지 |
| **크기(Severity)** | 기대 대비 차이가 의미 있는 수준인지 |
| **맥락 중요도(Context)** | 마감/중요 미팅/휴가 등 상황에서의 중요도 |
| **선호 위반(Preference Violation)** | 알림 최소화 선호인데 알림이 과다한지 등 |
| **미해결 비용(Cost)** | 놓칠 위험, 지연이 초래하는 비용 추정 |

**개인 베이스라인 우선 원칙**: 비교 기준은 외부 평균보다 **개인 베이스라인**(예: 과거 2-4주 평균)과 목표·맥락을 우선합니다.

---

## 6. 계층 상세 설계

### 6.1 World Model (세계 모델)

World Model은 사용자의 추상적 목표, 선호, 확정된 문제, 활성 에이전트를 저장하는 중앙 저장소입니다. 핵심은 **'규칙 저장'이 아니라 '방향성 저장'**이며, 구체적 기대 상태는 매 순간 맥락에 따라 동적으로 생성됩니다.

**저장 항목(스키마)**

```
User: (사용자 ID)
├── Abstract Goals: [사용자 입력]
├── Preferences: [개입 방식, 알림/자동화 수준 등]
├── Problem Candidates: [시스템 감지, 미확정]
├── Confirmed Problems: [사용자 확인 완료]
├── Active Agents: [승인 후 생성된 에이전트 목록]
├── Connected Sources: [연결된 MCP 및 권한 범위]
└── Safety/Policy: [허용 액션 allowlist, 금지 영역]
```

**예시: 다양한 도메인의 목표와 문제**

```
Abstract Goals
├── "업무 효율 높이고 싶어"
├── "중요한 거 놓치지 않고 싶어"
├── "개발 생산성 높이고 싶어"
├── "건강 관리 잘하고 싶어"
└── "돈 관리 잘하고 싶어"

Confirmed Problems (도메인별 예시)
├── [업무] "중요 메일 응답 지연" - 2025-01-02 확정
├── [업무] "회의 준비 시간 부족" - 2025-01-03 확정
├── [개발] "PR 리뷰 48시간 이상 방치" - 2025-01-04 확정
├── [개발] "빌드 실패 후 6시간 이상 방치" - 2025-01-05 확정
├── [건강] "수면 시간 불규칙" - 2025-01-06 확정
├── [건강] "운동 루틴 이탈" - 2025-01-07 확정
├── [재정] "반복 지출 패턴 감지" - 2025-01-08 확정
└── [재정] "미사용 구독 서비스" - 2025-01-09 확정

Active Agents (도메인별 예시)
├── 메일 자동 분류 에이전트 - 활성
├── 회의 준비 리마인더 에이전트 - 활성
├── PR 리뷰 리마인더 에이전트 - 활성
├── 수면 패턴 트래커 에이전트 - 활성
└── 지출 패턴 알림 에이전트 - 활성

Connected Sources
├── Gmail (읽기: 메타데이터, 쓰기: 라벨) ✓
├── Google Calendar (읽기) ✓
├── Slack (쓰기: DM/채널 메시지) ✓
├── GitHub (읽기: PR/이슈) ✓
├── Health App (읽기: 수면/운동) ✓
└── 가계부 앱 (읽기: 지출 내역) ✓
```

### 6.2 Sensor Layer (센서 계층)

Sensor Layer는 MCP를 통해 사용자의 일상 데이터를 수집합니다. 목적은 **'해결'이 아니라 '관찰'**이며, 초기에는 읽기 전용·메타데이터 중심으로 시작합니다.

**연결 가능한 소스 (도메인별)**

| 카테고리 | 소스 | 수집 데이터 |
|----------|------|-------------|
| **커뮤니케이션** | Gmail, Slack, Teams | 응답 시간, 대화 패턴, 미확인 메시지 |
| **생산성** | Calendar, Notion, Trello | 일정 분포, 작업 완료율, 마감 준수율 |
| **개발** | GitHub, GitLab, Jira | PR 리뷰 시간, 이슈 처리 속도, 빌드 성공률 |
| **건강** | Apple Health, Fitbit, 수면 앱 | 수면 패턴, 활동량, 심박수 |
| **재정** | 가계부 앱, 은행 앱 | 지출 패턴, 카테고리별 소비, 구독 결제 |
| **학습** | 강의 플랫폼, 독서 앱 | 학습 시간, 완료율, 진도 |

**수집 원칙**

| 원칙 | 설명 |
|------|------|
| **최소 권한** | 초기는 메타데이터 중심으로 시작, 본문 접근은 별도 동의 |
| **데이터 최소화** | 원본 콘텐츠 영구 저장 지양, 특징/패턴 위주 저장 |
| **민감도 등급** | 저장 전 민감도 분류 및 마스킹/해시/토큰화 정책 적용 |
| **보관기간** | 명시적 보관기간(30/90/180일), 사용자 삭제/다운로드 권한 |

### 6.3 Expectation Layer (기대 계층)

Expectation Layer는 World Model의 추상적 목표를 현재 맥락에 맞는 **구체적 기대 상태(Expectation)**로 변환합니다.

**도메인별 목표 해석 예시**

| 추상적 목표 | 맥락 | 기대 상태 |
|-------------|------|-----------|
| "업무 효율 높이고 싶어" | 평일 오전 9시, 중요 미팅 1시간 전 | 미팅 관련 메일/문서 즉시 확인 필요 |
| "업무 효율 높이고 싶어" | 금요일 오후 6시, 퇴근 후 | 긴급 연락 외 월요일 처리 가능 |
| "개발 생산성 높이고 싶어" | PR이 48시간 이상 리뷰 대기 중 | 리뷰 지연 상태, 리마인더 필요 |
| "건강 관리 잘하고 싶어" | 취침 시간 편차 2시간 이상 | 수면 패턴 불규칙 상태 |
| "돈 관리 잘하고 싶어" | 배달앱 주간 지출 8만원 초과 | 반복 지출 패턴 감지 |

**해석 불확실성 처리**

```
SIA 가설: "업무 효율" = "중요한 커뮤니케이션에 빠르게 대응"

확인 질문: "중요 메일 응답 지연이 불편하신가요?"

- 사용자: "맞아" → 가설 강화, 관련 문제 후보 탐색
- 사용자: "아니, 메일은 괜찮아. 회의가 너무 많아" → 가설 수정
```

### 6.4 Comparison Layer (비교 계층)

Comparison Layer는 현재 상태와 기대 상태를 비교해 **Gap**을 계산합니다.

**Gap 유형**

| 유형 | 예시 |
|------|------|
| **정량 Gap** | 기대 1시간, 현재 4시간 → 3시간 초과 |
| **패턴 Gap** | 마감 전날 작업량 3배 집중 → 불균등 분배 |
| **이상 징후 Gap** | 평소 월요일 오전 메일 처리, 이번 주 미접근 → 패턴 이탈 |

**Gap 필터링 기준**

| 기준 | 의미 |
|------|------|
| 지속성 | 반복/추세인지 |
| 크기 | 노이즈 수준을 넘는지 |
| 맥락 적합성 | 현재 상황에서 중요도가 높은지 |
| 사용자 선호 | 개입/알림 선호와 충돌 여부 |
| 데이터 신뢰도 | 센서 누락/오류 가능성 고려 |

### 6.5 Interpretation Layer (해석 계층)

Interpretation Layer는 Gap을 사람이 이해할 수 있는 **'문제 설명'**으로 변환합니다.

**도메인별 해석 예시**

```
[업무 도메인]
Gap: 중요 메일 응답 시간이 개인 베이스라인 대비 +3시간 지연

문제 설명(가설):
- 중요한 요청이 다른 메일에 묻혀 응답이 늦어지고 있을 수 있습니다.
가능한 원인:
- 시간순 정렬로 중요 메일 가시성이 낮음
미해결 시 영향:
- 협업 파트너 응답 대기 증가
```

```
[개발 도메인]
Gap: PR 생성 후 평균 72시간 리뷰 대기

문제 설명(가설):
- PR 리뷰가 지연되어 머지 사이클이 느려지고 있습니다.
가능한 원인:
- 리뷰어에게 알림이 효과적으로 전달되지 않음
- 금요일 PR이 주말 동안 방치됨
미해결 시 영향:
- 개발 속도 저하, 코드 충돌 증가
```

```
[건강 도메인]
Gap: 취침 시간 편차 2시간 30분, 주중 평균 수면 5.5시간

문제 설명(가설):
- 수면 패턴이 불규칙하여 수면 부채가 누적되고 있습니다.
가능한 원인:
- 야근/늦은 퇴근 패턴
- 취침 전 스크린 타임
미해결 시 영향:
- 집중력 저하, 장기적 건강 리스크
```

```
[재정 도메인]
Gap: 배달앱 주간 지출 8.2만원 (월 33만원 예상)

문제 설명(가설):
- 배달앱 지출이 반복적으로 발생하고 있습니다.
가능한 원인:
- 야근 시 식사 해결 패턴
- 습관적 주문
미해결 시 영향:
- 월 예산 초과, 저축 목표 미달
```

### 6.6 Exploration Layer (탐색 계층)

Exploration Layer는 확정 문제를 해결할 수 있는 **'에이전트 후보'**를 탐색·평가합니다.

**평가 기준**

| 기준 | 설명 |
|------|------|
| **효과성** | 문제 지표를 실제로 개선할 가능성 |
| **선호 일치** | 알림 최소화/승인 기반 등 사용자 선호와의 일치 |
| **구현 가능성** | 연결된 MCP 및 권한으로 구현 가능한지 |
| **부작용** | 알림 피로, 잘못된 자동화 등 부정적 영향 |
| **운영 비용** | 비용/지연/유지보수 복잡도 |

### 6.7 Proposal Layer (제안 계층)

Proposal Layer는 문제의 근거, 예상 효과, 필요한 권한, 부작용 가능성을 함께 제시합니다.

**제안 메시지 템플릿**

```
[발견한 문제]
- 관찰 기간: 최근 2주
- 지표: 중요 메일 응답시간 (개인 베이스라인 1.5h → 현재 4.0h)
- 패턴: 특정 발신자 메일이 묻히는 경향

[제안하는 에이전트]
- 이름: 메일 자동 분류 에이전트
- 하는 일: 중요도 라벨링 + 일일 요약
- 필요한 권한: Gmail 라벨 생성/적용(쓰기)
- 부작용/주의: 오분류 가능, 피드백 필요

[선택]
[만들어줘] [다른 대안 보기] [이건 문제 아님] [나중에]
```

### 6.8 Composition Layer (구성 계층)

Composition Layer는 승인된 에이전트를 실제 실행 가능한 워크플로우로 구성합니다.

#### "에이전트"란 무엇인가?

SIA가 생성하는 "에이전트"는 다음 요소로 구성된 **자동화된 워크플로우 시스템**입니다:

```
┌─────────────────────────────────────────────────────────┐
│                    에이전트 구성 요소                    │
├─────────────────────────────────────────────────────────┤
│  1. 트리거(Trigger)                                     │
│     - 언제 실행할지 (이벤트/시간/조건 기반)              │
│     - 예: "새 메일 도착 시", "매일 오전 9시"            │
│                                                         │
│  2. 입력(Inputs)                                        │
│     - 어떤 데이터를 읽을지 (메타데이터/제목/본문)        │
│     - 예: "메일 발신자, 제목, 시간"                     │
│                                                         │
│  3. 도구(Tools/MCP)                                     │
│     - 어떤 외부 시스템에 접근할지                       │
│     - 예: "Gmail MCP (읽기+라벨쓰기)", "Slack MCP"      │
│                                                         │
│  4. 처리 로직(Logic)                                    │
│     - LLM 기반 판단 또는 규칙 기반 처리                 │
│     - 예: "발신자가 VIP면 중요도=높음"                  │
│                                                         │
│  5. 실행 액션(Actions)                                  │
│     - 결과물 생성 (라벨 추가, 알림 전송, 리포트 생성)    │
│     - 예: "중요 메일에 ⭐ 라벨 추가"                    │
│                                                         │
│  6. 안전 정책(Safety)                                   │
│     - 승인 필요 여부, 리스크 등급, 제한 정책            │
│     - 예: "쓰기 작업은 사용자 승인 필요"                │
└─────────────────────────────────────────────────────────┘
```

**핵심**: 에이전트는 코드가 아닙니다. 사용자가 코드를 볼 필요도, 수정할 필요도 없습니다. SIA가 내부적으로 MCP 연결과 로직을 조합하여 실행 가능한 워크플로우를 생성합니다.

#### 도메인별 에이전트 구성 예시

**예시 1: 메일 자동 분류 에이전트**

```yaml
agent_id: mail_triage_v1
domain: 업무/커뮤니케이션
risk_level: low

trigger:
  type: event
  source: gmail
  event: new_email

inputs:
  scope: metadata_and_subject

tools:
  - name: gmail
    permissions:
      read: [metadata, subject]
      write: [apply_label]
  - name: slack
    permissions:
      write: [send_dm]

logic:
  rules:
    - if: sender in VIP_LIST
      then: importance = high
    - if: subject contains ["마감", "긴급", "요청"]
      then: importance = high
  llm:
    enabled: true
    task: classify_importance

actions:
  - if: importance == high
    do: gmail.apply_label("⭐_Important")
  - schedule: daily_09:00
    do: slack.send_dm(daily_summary)

metrics:
  - important_email_response_time
  - missed_important_emails
```

**예시 2: PR 리뷰 리마인더 에이전트**

```yaml
agent_id: pr_review_reminder_v1
domain: 개발
risk_level: low

trigger:
  - type: schedule
    cron: "0 10 * * 1-5"  # 평일 오전 10시
  - type: condition
    check: pr_age > 24h AND no_review

inputs:
  scope: pr_metadata

tools:
  - name: github
    permissions:
      read: [pull_requests, reviews]
  - name: slack
    permissions:
      write: [send_dm, send_channel]

logic:
  rules:
    - if: pr_age > 48h AND is_release_branch
      then: urgency = critical
    - if: pr_age > 24h
      then: urgency = high
  
actions:
  - if: urgency >= high
    do: slack.send_dm(reviewer, reminder_message)
  - schedule: weekly_monday
    do: slack.send_channel(team, weekly_pr_summary)

metrics:
  - pr_review_time
  - pr_merge_cycle_time
```

**예시 3: 수면 패턴 트래커 에이전트**

```yaml
agent_id: sleep_tracker_v1
domain: 건강
risk_level: low

trigger:
  - type: schedule
    cron: "0 22 * * *"  # 매일 저녁 10시

inputs:
  scope: health_sleep_data

tools:
  - name: health_app
    permissions:
      read: [sleep_records]
  - name: calendar
    permissions:
      read: [next_day_events]
  - name: notification
    permissions:
      write: [push_notification]

logic:
  rules:
    - calculate: recommended_bedtime = first_event_time - 8h
    - if: current_time > recommended_bedtime - 1h
      then: send_reminder
  analysis:
    - weekly_sleep_debt_calculation
    - pattern_irregularity_detection

actions:
  - do: notification.push("내일 {first_event}이 있어요. {recommended_bedtime} 전 취침 권장!")
  - schedule: weekly_sunday
    do: notification.push(weekly_sleep_report)

metrics:
  - sleep_time_variance
  - average_sleep_duration
```

**예시 4: 지출 패턴 알림 에이전트**

```yaml
agent_id: spending_alert_v1
domain: 재정
risk_level: low

trigger:
  - type: event
    source: finance_app
    event: new_transaction
  - type: schedule
    cron: "0 9 * * 1"  # 매주 월요일 오전 9시

inputs:
  scope: transaction_metadata

tools:
  - name: finance_app
    permissions:
      read: [transactions, subscriptions]
  - name: notification
    permissions:
      write: [push_notification]

logic:
  rules:
    - if: category_weekly_total > category_threshold
      then: send_alert
    - if: subscription.last_used > 90_days
      then: flag_unused_subscription
  analysis:
    - recurring_spending_pattern_detection
    - category_comparison_vs_baseline

actions:
  - if: threshold_exceeded
    do: notification.push("이번 주 {category} 지출이 {amount}을 넘었어요")
  - schedule: monthly_first
    do: notification.push(monthly_spending_report)

metrics:
  - category_spending_vs_budget
  - unused_subscription_count
```

#### 동적 도구 선택

SIA는 연결된 MCP 중에서 문제 해결에 필요한 것을 **자동으로 선택**합니다.

```
연결된 MCP: [Gmail, Calendar, Slack, GitHub, Health App, 가계부 App]

문제: "PR 리뷰 지연"
→ 선택: GitHub (필수), Slack (알림)
→ 미사용: Gmail, Calendar, Health App, 가계부 App

문제: "수면 패턴 불규칙"
→ 선택: Health App (필수), Calendar (맥락), 알림
→ 미사용: Gmail, Slack, GitHub, 가계부 App

문제: "반복 지출 패턴"
→ 선택: 가계부 App (필수), 알림
→ 미사용: Gmail, Calendar, Slack, GitHub, Health App
```

### 6.9 Execution Layer (실행 계층)

Execution Layer는 구성된 에이전트를 배포하고 실행합니다.

**운영 체크리스트**

| 항목 | 설명 |
|------|------|
| **멱등성** | 동일 이벤트에 라벨/메시지 중복 적용 방지 |
| **레이트리밋/백오프** | 외부 API 쿼터 초과 시 지수 백오프 |
| **부분 실패 처리** | 일부 액션 실패 시 재시도/보상 트랜잭션 |
| **드라이런/프리뷰** | 쓰기 작업은 변경사항 요약 후 승인 |
| **롤백** | 오작동 시 빠른 비활성화 및 원상복구 절차 |

### 6.10 Learning Layer (학습 계층)

Learning Layer는 실행 결과와 사용자 피드백을 통해 World Model과 에이전트 로직을 업데이트합니다.

**학습 신호**

| 신호 유형 | 예시 |
|-----------|------|
| **사용자 피드백** | '이건 중요해요/아니에요', '제안 거절/보류' |
| **효과 지표** | 응답시간/누락 건수/마감 준수율 등의 전후 변화 |
| **부작용 지표** | 알림 무시율, 차단율, 오분류 수정 빈도 |
| **행동 변화** | 에이전트 적용 후 패턴 변화 |

---

## 7. 횡단 레이어: 정책/보안/관측

### 7.1 Policy & Consent (정책 및 동의)

**권한 모델**

| 원칙 | 설명 |
|------|------|
| **Read-only by default** | 관찰 단계에서는 읽기 전용으로 시작 |
| **Scoped permission** | 필요 최소 범위로 권한 제한 |
| **Action allowlist** | 허용된 액션만 실행 |
| **Approval gates** | 리스크/액션 등급에 따라 사용자 승인 요구 |
| **Revocation** | 사용자가 언제든 권한 철회/연결 해제 가능 |

### 7.2 Security & Safety (보안 및 안전)

**위협 모델과 대응**

| 위협 | 대응 |
|------|------|
| **프롬프트 인젝션** | 외부 텍스트의 '지시문' 무시, 시스템 프롬프트/정책 우선 |
| **데이터 유출** | 민감도 분류/마스킹, 최소 수집, 접근 로그, 테넌트 격리 |
| **도구 오용** | 레이트리밋, allowlist/denylist, 위험 액션 차단 |
| **권한 과다** | 권한 범위 최소화, 단계적 권한 상승, 정기 권한 리뷰 |

### 7.3 Observability & Auditing (관측 및 감사 추적)

**권장 로그 구조**

```
Proposal Log
- timestamp, problem_candidate_id
- evidence: (지표/추세/맥락)
- proposal_text, alternatives_shown
- user_decision: approve/reject/snooze/edit

Execution Log
- timestamp, agent_id, trigger_event_id
- tool_calls: (name, scope, success/fail)
- actions: (write ops summary)
- outcome_metrics: (전후 지표)
```

---

## 8. 운영 전략

### 8.1 다중 에이전트 충돌 관리

여러 에이전트가 동시에 활성화되면 동일 리소스에 충돌이 발생할 수 있습니다.

**충돌 시나리오 예시**

```
시나리오: 메일 분류 에이전트 + 회의 준비 에이전트가 동시에 같은 메일을 처리

- 메일 분류 에이전트: "이 메일은 마케팅 카테고리" → 라벨 적용
- 회의 준비 에이전트: "이 메일은 내일 회의 관련" → 다른 라벨 적용

충돌: 동일 메일에 대한 라벨링 정책 충돌
```

**해결 메커니즘**

| 메커니즘 | 설명 |
|----------|------|
| **리소스 락** | 동일 리소스에 대한 쓰기 작업 직렬화 |
| **우선순위 중재자** | 목표 중요도, 리스크 등급, 사용자 선호 기반 우선순위 결정 |
| **사전 프리뷰** | 충돌 가능 작업은 실행 전 변경 요약 제시 |
| **정책 기반 거부** | 특정 조합은 금지 |

### 8.2 티어드 인퍼런스(Tiered Inference)

모든 판단을 LLM으로 수행하면 비용·지연·재현성이 불안정해질 수 있습니다.

**3단계 파이프라인**

```
1) Cheap Detection
   - 규칙/통계로 이상 후보 추출
   - 예: 응답시간 급증, 미확인 수 급증

2) Expensive Interpretation
   - LLM으로 원인 가설/설명/대안 생성

3) Guarded Execution
   - 정책 엔진 + 승인(필요 시) 후 도구 실행
```

---

## 9. 사용자 경험(UX) 흐름

### 9.1 온보딩

**Step 1: 목표 입력 (2분)**

```
"안녕하세요! 저는 SIA입니다.
 구체적인 문제를 말씀하실 필요 없어요.
 대략적인 방향만 알려주세요."

☐ 업무 효율 높이고 싶어
☐ 중요한 거 놓치지 않고 싶어
☐ 개발 생산성 높이고 싶어
☐ 건강 관리 잘하고 싶어
☐ 돈 관리 잘하고 싶어
☐ 뭔가 비효율적인데 뭔지 모르겠어
☐ 직접 입력: _______________
```

**Step 2: 데이터 소스 연결 (3분)**

```
"좋아요! 이제 상황을 파악하기 위해 서비스를 연결해주세요."

[업무/생산성]
☐ Gmail - 메일 패턴 분석
☐ Google Calendar - 일정 패턴 분석
☐ Slack - 커뮤니케이션 패턴 분석

[개발] (개발자인 경우)
☐ GitHub - PR/이슈 처리 패턴 분석
☐ Jira - 태스크 관리 패턴 분석

[건강/습관]
☐ Apple Health / Fitbit - 수면, 운동 패턴 분석

[재정]
☐ 가계부 앱 - 지출 패턴 분석

* 모든 연결은 읽기 전용으로 시작합니다.
```

**Step 3: 선호 설정 (1분)**

```
개입 빈도:
☐ 적극적으로 알려줘 (문제 발견할 때마다)
☐ 적당히 (중요한 것만)
☐ 최소한으로 (주간 요약만)

자동화 수준:
☐ 제안만 해줘, 실행은 내가 결정
☐ 간단한 건 알아서 해도 돼
```

**Step 4: 관찰 시작**

```
"설정 완료! 이제 1-2주간 관찰할게요.
 관찰 기간 동안은 아무것도 바꾸지 않아요.
 문제를 발견하면 알려드릴게요."

[SIA 상태: 관찰 중 🔍]
```

### 9.2 문제 발견 및 제안 (1-2주 후)

```
[SIA 첫 리포트]

"2주간 관찰 결과, 몇 가지 발견했어요."

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🔍 발견 1: PR 리뷰 지연 (GitHub)

관찰 내용:
• PR 생성 후 첫 리뷰까지 평균 72시간
• 금요일 PR이 월요일까지 방치되는 패턴

💡 제안: PR 리뷰 리마인더 에이전트
   → [만들어줘] [자세히 보기] [이건 문제 아니야]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🔍 발견 2: 수면 패턴 불규칙 (Health App)

관찰 내용:
• 취침 시간 편차: 평균 2시간 30분
• 주중 평균 수면: 5.5시간

💡 제안: 수면 패턴 트래커 에이전트
   → [만들어줘] [자세히 보기] [이건 문제 아니야]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🔍 발견 3: 반복 지출 패턴 (가계부 앱)

관찰 내용:
• 배달앱 지출: 주 평균 8.2만원 (월 33만원)
• 미사용 구독 서비스 3개 감지 (월 2.9만원)

💡 제안: 지출 패턴 알림 에이전트
   → [만들어줘] [자세히 보기] [이건 문제 아니야]
```

### 9.3 제안 피로 완화

| 전략 | 설명 |
|------|------|
| **기본 모드** | 주간 요약 + 긴급/고위험만 즉시 개입 |
| **제안 예산** | 사용자에게 '이번 주 최대 제안 수' 컨트롤 제공 |
| **학습** | 연속 보류/거절 시 동일 유형 제안 빈도 자동 감소 |
| **대안 제시** | 같은 문제라도 '알림형/요약형/자동화형' 옵션 함께 제공 |

---

## 10. 프라이버시 및 데이터 거버넌스

### 10.1 데이터 분류와 최소화

**민감도 등급**

| 등급 | 예시 | 처리 |
|------|------|------|
| **Low** | 집계된 응답시간 평균, 메시지 개수 | 저장 가능 (보관기간 적용) |
| **Medium** | 발신자 도메인/역할, 제목 키워드 통계 | 마스킹/해시 후 저장, 접근 로그 |
| **High** | 본문 텍스트, 개인 식별 정보 | 기본 저장 금지. 명시 동의 + 단기 처리 + 즉시 폐기 |

### 10.2 보관기간 및 사용자 권리

| 권리 | 설명 |
|------|------|
| **보관기간 설정** | 관찰/특징/로그 각각의 보관기간 명시 (기본값 제공) |
| **삭제/내보내기** | 사용자가 자신의 데이터/로그를 삭제하거나 내보낼 수 있음 |
| **연결 해제** | MCP 연결 해제 시 수집 중단 및 저장 데이터 처리 정책 제공 |

---

## 11. 측정 지표(KPI) 및 품질 관리

### 11.1 문제 발견(Discovery) KPI

| 지표 | 정의/목적 |
|------|-----------|
| **제안 수/주** | 사용자 피로 관리를 위해 상한 제어 |
| **제안 승인율** | 제안이 유의미한지 간접 측정 |
| **거절율/보류율** | 문제 해석이 틀렸거나 타이밍이 나쁜 경우 탐지 |
| **사후 확인 정밀도** | 사용자 피드백 기준 '실제 문제였다' 비율 |

### 11.2 에이전트 효과(Impact) KPI

| 지표 | 예시 |
|------|------|
| **응답시간 개선** | 중요 메일 응답시간의 전후 비교 |
| **누락 감소** | 중요 요청 놓침 건수 감소 |
| **마감 준수율** | 마감 지연 비율 감소 |
| **알림 피로** | 알림 무시율/차단율/해지율 |
| **오작동률** | 오분류 수정 빈도, 실행 실패율 |

### 11.3 품질 게이팅

자동 생성된 에이전트는 배포 전후로 품질 게이트를 통과해야 합니다:

1. 드라이런에서 예상 변경사항이 정책 위반이 없음
2. 초기 1주 오작동률이 임계값 이하
3. 사용자 해지율이 임계값 이하

---

## 12. 콜드 스타트 전략

관찰 기간(1-2주) 전에도 최소한의 가치를 제공하기 위한 전략입니다.

### 12.1 목표 기반 초기 추천

```
사용자 목표: "업무 효율 높이고 싶어"
연결된 소스: Gmail, Calendar

초기 제안 (관찰 전):
"비슷한 목표를 가진 사용자들이 자주 겪는 문제예요.
 혹시 해당되는 게 있나요?"

☐ 중요한 메일이 다른 메일에 묻혀요
☐ 회의 준비 시간이 부족해요
☐ 마감 전에 일이 몰려요
☐ 아직 모르겠어요 (관찰 후 알려주세요)
```

### 12.2 도메인 기본값

| 도메인 | 기본 탐지 규칙 (관찰 시작 시 적용) |
|--------|-----------------------------------|
| **메일** | 48시간 이상 미확인 메일 존재 시 문제 후보 |
| **캘린더** | 회의 30분 전 관련 문서 미접근 시 문제 후보 |
| **GitHub** | PR 48시간 이상 리뷰 없음 시 문제 후보 |
| **건강** | 수면 시간 편차 2시간 이상 시 문제 후보 |

### 12.3 점진적 학습

```
1주차: 도메인 기본값으로 탐지
       ↓
2주차: 개인 베이스라인 계산 완료
       ↓
3주차~: 개인화된 Problem Score 적용
```

---

## 13. MVP 검증 계획

### 13.1 범위(Scope)

| 항목 | 내용 |
|------|------|
| **도메인** | Gmail + Google Calendar (필수), Slack (선택) |
| **권한** | 관찰 단계는 읽기 전용. 쓰기 작업은 승인 후 제한적 허용 |
| **기간** | 관찰 2주 + 적용 2주 (전후 비교) |
| **대상** | 내부 팀/파일럿 사용자 10-30명 |

### 13.2 성공 기준(Success Criteria)

| 항목 | 목표 |
|------|------|
| 제안 승인율 | ≥ 30% |
| 문제 제안 정밀도 | ≥ 70% (사용자 확인 기준) |
| 핵심 지표 개선 | 승인된 에이전트의 타깃 지표 20%+ 개선 |
| 해지/차단율 | < 10% |
| 주관 만족도 | 설문 평균 4/5 이상 |

### 13.3 실험 설계

- A/B 또는 단계적 롤아웃으로 '제안만'과 '승인 후 실행' 그룹 비교
- 문제 유형별로 샘플 확보해 정밀도/효과 분리 측정

---

## 14. 한계 및 미해결 과제

### 14.1 이론적 한계

- **추상 목표 해석의 불확실성**: 개인차가 크며 완벽한 해석은 불가능
- **문제의 주관성**: 시스템이 문제라 판단해도 사용자는 아니라고 느낄 수 있음
- **인과관계 단정의 어려움**: 상관관계 기반의 가설 수준에서 운영해야 함

### 14.2 기술적 과제

| 과제 | 설명 |
|------|------|
| **에이전트 품질 측정** | 자동 생성 산출물의 안전/효과 기준 확립 |
| **다중 에이전트 충돌** | 리소스 락/중재/정책의 정교화 |
| **롤백/복구** | 오작동을 신속히 되돌리는 운영 체계 |
| **프라이버시/보안** | 민감도 분류, 권한 최소화, 감사 체계 강화 |
| **콜드 스타트** | 관찰 기간 전에도 최소한의 가치 제공 |

---

## 15. 결론

SIA는 '사용자가 문제를 정의해야만 작동하는 에이전트' 패러다임을 바꾸려는 시도입니다.

**기존**: 사용자가 문제를 알아야 하고, 에이전트를 설계해야 합니다.
**SIA**: 사용자는 방향만 제시하고, AI가 문제를 발견하고 에이전트를 만듭니다.

### 핵심 아이디어

1. 사용자의 **추상적 목표**를 받아들입니다 ("업무 효율 높이고 싶어")
2. **관찰**을 통해 구체적인 **문제를 발견**합니다 ("메일 응답 지연이 문제입니다")
3. 문제 해결을 위한 **에이전트를 자동으로 구성**합니다 ("메일 분류 에이전트를 만들어드릴까요?")

### 핵심 차별점

1. **Problem Discovery의 정밀도와 사용자 신뢰**
2. **안전한 도구 실행 (정책/승인)**
3. **개인화 학습 루프**

본 문서의 KPI와 MVP 검증 계획을 통해 이 접근이 실제로 유용한지 단계적으로 입증할 수 있습니다.

---

## 참고 문헌

**[1]** Lu, Y., Yang, S., Qian, C., et al. (2025). Proactive Agent: Shifting LLM Agents from Reactive Responses to Active Assistance. _ICLR 2025_. https://arxiv.org/abs/2410.12361

**[2]** Anthropic. (2024). Model Context Protocol Specification. https://modelcontextprotocol.io/

---

**Self-Initiating Agent Architecture (SIA) — White Paper v3.2**

_작성일: 2025년 1월 5일_
_원작성자: 강성훈_